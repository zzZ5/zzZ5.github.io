<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python技巧与规范整理 | zzZ5的博客</title><meta name="author" content="zzZ5"><meta name="copyright" content="zzZ5"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我在日常使用和学习Python时收集的技巧规范.">
<meta property="og:type" content="article">
<meta property="og:title" content="Python技巧与规范整理">
<meta property="og:url" content="https://zzz5.xyz/2019/05/09/python/rules/python-rule-tips/index.html">
<meta property="og:site_name" content="zzZ5的博客">
<meta property="og:description" content="我在日常使用和学习Python时收集的技巧规范.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/03/kT3orwCEb92zaue.png">
<meta property="article:published_time" content="2019-05-09T13:27:00.000Z">
<meta property="article:modified_time" content="2020-07-02T13:23:44.000Z">
<meta property="article:author" content="zzZ5">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/03/kT3orwCEb92zaue.png"><link rel="shortcut icon" href="/assets/img/zzz5.ico"><link rel="canonical" href="https://zzz5.xyz/2019/05/09/python/rules/python-rule-tips/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-RHY2S6DLG5"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-RHY2S6DLG5');
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python技巧与规范整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-07-02 21:23:44'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="zzZ5的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2020/06/03/OFvA9uNmodI8tki.png" onerror="onerror=null;src='/assets/blogImg/404.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photo/"><i class="fa-fw far fa-image"></i><span> Photo</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/animate/"><i class="fa-fw fab fa-youtube"></i><span> Animate</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/06/03/kT3orwCEb92zaue.png')"><nav id="nav"><span id="blog-info"><a href="/" title="zzZ5的博客"><span class="site-name">zzZ5的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photo/"><i class="fa-fw far fa-image"></i><span> Photo</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/animate/"><i class="fa-fw fab fa-youtube"></i><span> Animate</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python技巧与规范整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-09T13:27:00.000Z" title="发表于 2019-05-09 21:27:00">2019-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-02T13:23:44.000Z" title="更新于 2020-07-02 21:23:44">2020-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python%E6%8A%80%E5%B7%A7%E5%92%8C%E8%A7%84%E8%8C%83/">python技巧和规范</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python技巧与规范整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文章持续随缘更新.<br><code>最后更新时间:  2019-08-24</code></p>
<h2 id="如何立即跳出两层嵌套循环"><a href="#如何立即跳出两层嵌套循环" class="headerlink" title="如何立即跳出两层嵌套循环"></a>如何立即跳出两层嵌套循环</h2><p>两层循环:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> listA:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> listB:</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            <span class="keyword">break</span>   <span class="comment"># 如何 break 两次呢?</span></span><br></pre></td></tr></table></figure>

<p>一般跳出两层嵌套循环有以下几种常见的方法:</p>
<ol>
<li>将循环放在一个函数中进行, 利用函数返回来跳出循环. 但这样的做法不尽如人意, 因为循环可能不适合重构为一个新的函数, 也许你需要在循环的过程中访问其他局部变量.</li>
<li>抛出异常, 并在两重循环之外捕获它. 这是把异常当作 goto 语句来用了. 但是这里并没有异常的条件, 只是变向地利用了异常机制.</li>
<li>使用布尔变量来标记循环的结束, 并在外循环中检查变量值以执行第二次 break 操作. 该方法毫无技术成分, 某些情况下可能是有效的, 但大多数情况下只造成计算资源浪费, 程序效率不高.<br>而对于python, 有更为简单的方法, python非常擅长抽象化迭代过程, 如果把python当作一般的语言来使用, 不能发挥循环抽象的优势. 我们甚至可以把两层循环抽象为一层循环, 可以思考一下, 如何用python的语法将两层循环改写为一层循环?</li>
</ol>
<p>下面给出答案:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_pairs</span>(<span class="params">listA, listB</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在listA和listB范围中生成索引对&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> listA:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> listB:</span><br><span class="line">            <span class="keyword">yield</span> i, j</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> get_index(listA, listB):</span><br><span class="line">    <span class="keyword">if</span> i == j:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>此处, 我们写了一个生成器用于生成需要的索引对. 现在, 我们的循环就成了对索引对的一重循环, 而不是对索引的两重循环. 两重循环依然存在, 只是被抽象了出去, 移到了 get_pairs() 方法里面.<br>这使我们的代码更贴近自然语言的描述. 而且, 如果在其他地方也需要这样迭代的话, 还能复用 get_pairs 生成器.</p>
<h2 id="Python函数是传值还是传引用"><a href="#Python函数是传值还是传引用" class="headerlink" title="Python函数是传值还是传引用"></a>Python函数是传值还是传引用</h2><p>关于Python函数是传值还是传引用, 总结起来大概有三种说法:</p>
<ul>
<li>1.传引用, 类似于C语言的指针, 传入参数的引用, 当更改传入值时, 原值也会改变.<br>下面举一个例子:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changeValue</span>(<span class="params">x</span>):</span><br><span class="line">    x = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">origin_value = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;origin_value: &quot;</span>, origin_value)</span><br><span class="line">changeValue(origin_value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;changed: &quot;</span> + origin_value)</span><br><span class="line"><span class="comment"># 输出的值为:</span></span><br><span class="line">origin_value: a</span><br><span class="line">changed: a</span><br></pre></td></tr></table></figure>

<p>可以清楚地看到在函数内更改值, 原值并没有发生变化, 所以并不是传引用.</p>
<ul>
<li>2.传值, 和字面意思一样, 只是传入原对象的值的复制, 在函数内更改传入值, 并不会改变原值.<br>这时再举一个例子:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">changeList</span>(<span class="params">x</span>):</span><br><span class="line">    x.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">origin_list = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;origin_list: &quot;</span>, origin_list)</span><br><span class="line">changeList(origin_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;changed: &quot;</span>, origin_list)</span><br><span class="line"><span class="comment"># 输出结果为:</span></span><br><span class="line">origin_list:  [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">changed:  [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到, 在函数内更改列表的值时, 原列表的值也发生了变化, 所以并不是传值.</p>
<ul>
<li>3.可变对象传引用, 不可变对象传值<br>还举一个例子</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">changeList</span>(<span class="params">x</span>):</span><br><span class="line">    x = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">origin_list = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;origin_list: &quot;</span>, origin_list)</span><br><span class="line">changeList(origin_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;changed: &quot;</span>, origin_list)</span><br><span class="line"><span class="comment"># 输出结果为:</span></span><br><span class="line">origin_list:  [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">changed:  [<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到, 这次传入的参数虽然是可变对象, 但是并没有改变原来的值, 所以这个说法也不正确.</p>
<p>那么python函数传的参数到底是什么?</p>
<p>我们先看一下python在赋值语句中对应的内存变化图:</p>
<p><img src="/assets/blogImg/python/python01.jpg" alt="01"></p>
<p>在python中, 当b &#x3D; a 时, b 和 a 指向同一块内存, 而当再 b &#x3D; 7 时, 申请了一块新的值为7的内存, 再将b指向该内存, a的值并没有发生改变.</p>
<p>此时再回头看上述的例子, 对于示例1, x &#x3D; ‘b’, 由于x为字符, 是不可变对象, x &#x3D; ‘b’会重新申请一块内存, 其值为’b’, 并在函数体中将x指向它. 当调用完函数之后, 函数体中的局部变量在函数外不并不可见, 此时的origin_value值还是3. 而在示例2中, 在org_list中再添加一个元素’b’, 只是在内存中加入新值’b’, 这时x指向的地址, 即对象并没有被更改, 所以函数体外的origin_list的值也发生了改变. 而示例3中是直接申请了一块新的值为 [‘b’] 的内存, 再将函数中的x指向该内存, 所以并没有改变函数外origin_list的值.</p>
<p>因此, 对于Python函数参数是传值还是传引用这个问题的答案是: 都不是. 正确的叫法应该是传对象(call by object)或者说传对象的引用(call-by-object-reference). 函数参数在传递的过程中将整个对象传入, 对可变对象的修改在函数外部以及内部都可见, 调用者和被调用者之间共享这个对象, 而对于不可变对象, 由于并不能真正被修改, 因此, 修改往往是通过生成一个新对象然后赋值来实现的.</p>
<h2 id="默认参数问题"><a href="#默认参数问题" class="headerlink" title="默认参数问题"></a>默认参数问题</h2><p>从上文对python是传值还是传引用问题的探讨, 我们可以引出新的问题. 对于默认的可变对象, 如果我们在函数里 append() 后, 默认的可变对象会不会发生改变?<br>我们可以写段代码测试一下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">my_list=[<span class="string">&#x27;a&#x27;</span>]</span>):</span><br><span class="line">    my_list.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> my_list</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(change())</span><br><span class="line"><span class="built_in">print</span>(change())</span><br><span class="line"><span class="comment"># 输出结果为:</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>代码运行结果显示出默认的my_list在第一次调用后已经发生改变.可以看出Python函数的参数默认值, 是在编译阶段就绑定了对象的.</p>
<p>如何避免这个不必要的麻烦:<br>当然最好的方式是不要使用可变对象作为函数默认值. 如果非要这么用的话, 将默认值设为None是一个很好的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">my_list=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> my_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        my_list = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    my_list.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> my_list</span><br><span class="line"><span class="comment"># 输出结果为:</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>这样这个问题就能完美解决了.</p>
<hr>
<h2 id="Python中下划线的用法"><a href="#Python中下划线的用法" class="headerlink" title="Python中下划线的用法"></a>Python中下划线的用法</h2><table>
<thead>
<tr>
<th>模式</th>
<th>例子</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>单前导下划线</td>
<td>_var</td>
<td>命名约定, 表示这个变量是私有的. 它通常不由Python解释器强制执行, 仅仅作为程序员的约定俗成</td>
</tr>
<tr>
<td>单末尾下划线</td>
<td>var_</td>
<td>命名约定, 用来避免与Python关键字产生命名冲突</td>
</tr>
<tr>
<td>双前导下划线</td>
<td>__var</td>
<td>名称修饰(name mangling), 解释器会更改变量名, 以便在类被扩展的时候不容易产生冲突. 会将变量名更改为: _类名__var</td>
</tr>
<tr>
<td>双前导和末尾下划线</td>
<td>&#95;&#95;var&#95;&#95;</td>
<td>python内部用来表示特殊用途的方法</td>
</tr>
<tr>
<td>单下划线</td>
<td>_</td>
<td>用来表示某个临时的或无关紧要的变量</td>
</tr>
</tbody></table>
<h2 id="删除序列相同元素并保持顺序"><a href="#删除序列相同元素并保持顺序" class="headerlink" title="删除序列相同元素并保持顺序"></a>删除序列相同元素并保持顺序</h2><p>如果你仅仅就是想消除重复元素, 通常可以简单的构造一个集合, 将序列转换成集合. 然而, 这种方法不能保持元素的顺序, 生成的结果中的元素位置被打乱.<br>此时我们就可以巧妙地利用生成器来解决这个问题, 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe</span>(<span class="params">items</span>):    <span class="comment"># items 为 hashable 类型的序列</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="keyword">yield</span> item    <span class="comment"># 按顺序返回未重复的元素</span></span><br><span class="line">        seen.add(item)    <span class="comment"># hash表, 用以保存已经出现过的元素</span></span><br></pre></td></tr></table></figure>

<p>在使用时只需用该方法, 再将生成器转换为序列即可.</p>
<p>但是当该方法遇到 dict 类型的序列时, 就需做出些许改变:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe</span>(<span class="params">items, key=<span class="literal">None</span></span>):    <span class="comment"># items 可以为非 hashable 类型的序列, key为转换序列元素为 hashable 类型的函数</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        val = item <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> key(item)    <span class="comment"># 若 key 为 None 则不用转换</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item    <span class="comment"># 按顺序返回未重复的元素</span></span><br><span class="line">            seen.add(val)    <span class="comment"># hash表, 用以保存已经出现过的元素</span></span><br></pre></td></tr></table></figure>

<p>可以按下面样例使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;listA = [&#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>:<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;]</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>(dedupe(listA, key=<span class="keyword">lambda</span> d: (d[<span class="string">&#x27;x&#x27;</span>], d[<span class="string">&#x27;y&#x27;</span>])))</span><br><span class="line">[&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">3</span>&#125; ,&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;]</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>(dedupe(listA, key=<span class="keyword">lambda</span> d: d[<span class="string">&#x27;x&#x27;</span>]))</span><br><span class="line">[&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125; ,&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;]</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>(dedupe(listA, key=<span class="keyword">lambda</span> d: d[<span class="string">&#x27;y&#x27;</span>]))</span><br><span class="line">[&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">3</span>&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="Python中-号的特殊用法"><a href="#Python中-号的特殊用法" class="headerlink" title="Python中 * 号的特殊用法"></a>Python中 * 号的特殊用法</h2><h3 id="用作参数"><a href="#用作参数" class="headerlink" title="用作参数"></a>用作参数</h3><p>当星号用作参数时, 如 <code>*args, **kwargs</code> , 其中 <code>*args</code> 用来接受任意多个参数并将其放在 args元组 中, 而 <code>**kwargs</code> 用于接收类似于关键参数一样赋值的形式的多个实参放入 kwargs字典中.</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">func(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">#输出结果为:</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">func(a=<span class="string">&quot;a&quot;</span>, b=<span class="string">&quot;b&quot;</span>, c=<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="comment">#输出结果为:</span></span><br><span class="line">()</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, c=<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="comment">#输出结果为:</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用作解包"><a href="#用作解包" class="headerlink" title="用作解包"></a>用作解包</h3><p>函数在调用多个参数时, 在列表, 元组, 集合, 字典及其他可迭代对象作为实参, 并在前面加 * , 解释器将自动进行解包然后传递给多个单变量参数.</p>
<p>如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">listA = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">func(*listA)</span><br><span class="line"><span class="comment">#输出结果为:</span></span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line">dictA = &#123;<span class="string">&quot;a&quot;</span>:[<span class="number">1</span>, <span class="number">4</span>], <span class="string">&quot;b&quot;</span>:[<span class="number">2</span>, <span class="number">5</span>], <span class="string">&quot;c&quot;</span>:[<span class="number">3</span>, <span class="number">6</span>]&#125;</span><br><span class="line">zipped = <span class="built_in">zip</span>(*dictA.values())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))</span><br><span class="line"><span class="comment">#输出结果为:</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="将运算符映射到函数"><a href="#将运算符映射到函数" class="headerlink" title="将运算符映射到函数"></a>将运算符映射到函数</h2><p>下表显示了抽象操作如何与Python语法中的运算符符号以及 operator 模块中的函数相对应.</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>语法</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>加法</td>
<td>a + b</td>
<td>add(a, b)</td>
</tr>
<tr>
<td>字符串拼接</td>
<td>seq1 + seq2</td>
<td>concat(seq1, seq2)</td>
</tr>
<tr>
<td>包含测试</td>
<td>obj in seq</td>
<td>contains(seq, obj)</td>
</tr>
<tr>
<td>除法</td>
<td>a &#x2F; b</td>
<td>truediv(a, b)</td>
</tr>
<tr>
<td>除法取整</td>
<td>a &#x2F;&#x2F; b</td>
<td>floordiv(a, b)</td>
</tr>
<tr>
<td>按位与</td>
<td>a &amp; b</td>
<td>and_(a, b)</td>
</tr>
<tr>
<td>按位异或</td>
<td>a ^ b</td>
<td>xor(a, b)</td>
</tr>
<tr>
<td>按位取反</td>
<td>~ a</td>
<td>invert(a)</td>
</tr>
<tr>
<td>按位或</td>
<td>a &#124; b</td>
<td>or_(a, b)</td>
</tr>
<tr>
<td>取幂</td>
<td>a ** b</td>
<td>pow(a, b)</td>
</tr>
<tr>
<td>一致</td>
<td>a is b</td>
<td>is_(a, b)</td>
</tr>
<tr>
<td>不一致</td>
<td>a is not b</td>
<td>is_not(a, b)</td>
</tr>
<tr>
<td>索引赋值</td>
<td>obj[k] &#x3D; v</td>
<td>setitem(obj, k, v)</td>
</tr>
<tr>
<td>索引删除</td>
<td>del obj[k]</td>
<td>delitem(obj, k)</td>
</tr>
<tr>
<td>索引取值</td>
<td>obj[k]</td>
<td>getitem(obj, k)</td>
</tr>
<tr>
<td>左移</td>
<td>a &lt;&lt; b</td>
<td>lshift(a, b)</td>
</tr>
<tr>
<td>取余</td>
<td>a % b</td>
<td>mod(a, b)</td>
</tr>
<tr>
<td>乘法</td>
<td>a * b</td>
<td>mul(a, b)</td>
</tr>
<tr>
<td>矩阵乘法</td>
<td>a @ b</td>
<td>matmul(a, b)</td>
</tr>
<tr>
<td>否定(算术)</td>
<td>- a</td>
<td>neg(a)</td>
</tr>
<tr>
<td>否定(逻辑)</td>
<td>not a</td>
<td>not_(a)</td>
</tr>
<tr>
<td>正数</td>
<td>+ a</td>
<td>pos(a)</td>
</tr>
<tr>
<td>右移</td>
<td>a &gt;&gt; b</td>
<td>rshift(a, b)</td>
</tr>
<tr>
<td>切片赋值</td>
<td>seq[i:j] &#x3D; values</td>
<td>setitem(seq, slice(i, j), values)</td>
</tr>
<tr>
<td>切片删除</td>
<td>del seq[i:j]</td>
<td>delitem(seq, slice(i, j))</td>
</tr>
<tr>
<td>切片取值</td>
<td>seq[i:j]</td>
<td>getitem(seq, slice(i, j))</td>
</tr>
<tr>
<td>字符串格式化</td>
<td>s % obj</td>
<td>mod(s, obj)</td>
</tr>
<tr>
<td>减法</td>
<td>a - b</td>
<td>sub(a, b)</td>
</tr>
<tr>
<td>真值测试</td>
<td>obj</td>
<td>truth(obj)</td>
</tr>
<tr>
<td>比较(小于)</td>
<td>a &lt; b</td>
<td>lt(a, b)</td>
</tr>
<tr>
<td>比较(小于等于)</td>
<td>a &lt;&#x3D; b</td>
<td>le(a, b)</td>
</tr>
<tr>
<td>相等</td>
<td>a &#x3D;&#x3D; b</td>
<td>eq(a, b)</td>
</tr>
<tr>
<td>不等</td>
<td>a !&#x3D; b</td>
<td>ne(a, b)</td>
</tr>
<tr>
<td>比较(大于等于)</td>
<td>a &gt;&#x3D; b</td>
<td>ge(a, b)</td>
</tr>
<tr>
<td>比较(大于)</td>
<td>a &gt; b</td>
<td>gt(a, b)</td>
</tr>
</tbody></table>
<p>其中, 可以在自定义类中声明 <code>__lt__(a, b)</code> 等函数来使自定义类支持上表中的操作.</p>
<h2 id="格式字符串语法"><a href="#格式字符串语法" class="headerlink" title="格式字符串语法"></a>格式字符串语法</h2><p>str.format() 方法和 Formatter 类共享相同的格式字符串语法(虽然对于 Formatter 来说, 其子类可以定义它们自己的格式字符串语法). 具体语法与 格式化字符串字面值 相似, 但也存在区别.</p>
<p>格式字符串包含有以花括号 {} 括起来的”替换字段”. 不在花括号之内的内容被视为字面文本, 会不加修改地复制到输出中. 如果你需要在字面文本中包含花括号字符, 可以通过重复来转义: &#123;&#123; and &#125;&#125;.</p>
<p>替换字段的语法如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>replacement_field</td>
<td>“&#123; [field_name] [! conversion] [: format_spec] &#125;”</td>
</tr>
<tr>
<td>field_name</td>
<td>arg_name (.attribute_name &#124; [element_index])</td>
</tr>
<tr>
<td>arg_name</td>
<td>[identifier &#124; digit+]</td>
</tr>
<tr>
<td>attribute_name</td>
<td>identifier</td>
</tr>
<tr>
<td>element_index</td>
<td>digit+ &#124; index_string</td>
</tr>
<tr>
<td>conversion</td>
<td>“r” &#124; “s” &#124; “a”</td>
</tr>
<tr>
<td>format_spec</td>
<td>[[fill]align][sign][#][0][width][grouping_option][.precision][type]</td>
</tr>
<tr>
<td>fill</td>
<td>&lt;any character&gt;</td>
</tr>
<tr>
<td>align</td>
<td>“&lt;” &#124; “&gt;” &#124; “&#x3D;” &#124; “^”</td>
</tr>
<tr>
<td>sign</td>
<td>“+” &#124; “-“ &#124; “ “</td>
</tr>
<tr>
<td>width</td>
<td>digit+</td>
</tr>
<tr>
<td>grouping_option</td>
<td>“_” &#124; “,”</td>
</tr>
<tr>
<td>precision</td>
<td>digit+</td>
</tr>
<tr>
<td>type</td>
<td>“b” &#124; “c” &#124; “d” &#124; “e” &#124; “E” &#124; “f” &#124; “F” &#124; “g” &#124; “G” &#124; “n” &#124; “o” &#124; “s” &#124; “x” &#124; “X” &#124; “%”</td>
</tr>
</tbody></table>
<h3 id="field-name"><a href="#field-name" class="headerlink" title="field_name"></a>field_name</h3><p>用不太正式的术语来描述, 替换字段开头可以用一个 field_name 指定要对值进行格式化并取代替换字符被插入到输出结果的对象. field_name 之后有可选的 conversion 字段, 它是一个感叹号 ‘!’ 加一个 format_spec, 并以一个冒号 ‘:’ 打头. 这些指明了替换值的非默认格式.<br>field_name 本身以一个数字或关键字 arg_name 打头. 如果为数字, 则它指向一个位置参数, 而如果为关键字, 则它指向一个命名关键字参数. 如果格式字符串中的数字 arg_names 为 0, 1, 2, … 的序列, 它们可以全部省略(而非部分省略), 数字 0, 1, 2, … 将会按顺序自动插入. 由于 arg_name 不使用引号分隔, 因此无法在格式字符串中指定任意的字典键 (例如字符串 ‘10’ 或 ‘:-]’). arg_name 之后可以带上任意数量的索引或属性表达式. ‘.name’ 形式的表达式会使用 getattr() 选择命名属性, 而 ‘[index]’ 形式的表达式会使用 <code>__getitem__()</code> 执行索引查找.</p>
<h3 id="conversion"><a href="#conversion" class="headerlink" title="conversion"></a>conversion</h3><p>使用 conversion 字段在格式化之前进行类型强制转换. 通常, 格式化值的工作由值本身的 <code>__format__()</code> 方法来完成. 但是, 在某些情况下最好强制将类型格式化为一个字符串, 覆盖其本身的格式化定义. 通过在调用 <code>__format__()</code> 之前将值转换为字符串, 可以绕过正常的格式化逻辑.<br>目前支持的转换旗标有三种: ‘!s’ 会对值调用 str(), ‘!r’ 调用 repr() 而 ‘!a’ 则调用 ascii().</p>
<h3 id="format-spec"><a href="#format-spec" class="headerlink" title="format_spec"></a>format_spec</h3><p>format_spec 字段包含值应如何呈现的规格描述, 例如字段宽度, 对齐, 填充, 小数精度等细节信息. 每种值类型可以定义自己的”格式化语言”或对 format_spec 的解读方式.<br>如果指定了一个有效的 align 值, 则可以在该值前面加一个 fill 字符, 它可以为任意字符, 如果省略则默认为空格符. 在 格式化字符串字面值 或在使用 str.format() 方法时是无法使用花括号字面值 (“{“ or “}”) 作为 fill 字符的. 但是, 通过嵌套替换字段插入花括号则是可以的. 这个限制不会影响 format() 函数.</p>
<p>各种对齐选项的含义如下:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>‘&lt;’</td>
<td>强制字段在可用空间内左对齐(这是大多数对象的默认值).</td>
</tr>
<tr>
<td>‘&gt;’</td>
<td>强制字段在可用空间内右对齐(这是数字的默认值).</td>
</tr>
<tr>
<td>‘&#x3D;’</td>
<td>强制将填充放置在符号(如果有)之后但在数字之前. 这用于以”+000000120”形式打印字段.<br />此对齐选项仅对数字类型有效. 当’0’紧接在字段宽度之前时, 它成为默认值.</td>
</tr>
<tr>
<td>‘^’</td>
<td>强制字段在可用空间内居中.</td>
</tr>
</tbody></table>
<p>请注意, 除非定义了最小字段宽度, 否则字段宽度将始终与填充它的数据大小相同, 因此在这种情况下, 对齐选项没有意义.</p>
<p>sign 选项仅对数字类型有效, 可以是以下之一:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>‘+’</td>
<td>表示标志应该用于正数和负数.</td>
</tr>
<tr>
<td>‘-‘</td>
<td>表示标志应仅用于负数(这是默认行为).</td>
</tr>
<tr>
<td>space</td>
<td>表示应在正数上使用前导空格, 在负数上使用减号.</td>
</tr>
</tbody></table>
<p>‘#’ 选项可以让”替代形式”被用于转换. 替代形式可针对不同类型分别定义. 此选项仅对整数、浮点、复数和 Decimal 类型有效. 对于整数类型, 当使用二进制、八进制或十六进制输出时, 此选项会为输出值添加相应的 ‘0b’, ‘0o’ 或 ‘0x’ 前缀. 对于浮点数、复数和 Decimal 类型, 替代形式会使得转换结果总是包含小数点符号, 即使其不带小数. 通常只有在带有小数的情况下, 此类转换的结果中才会出现小数点符号. 此外, 对于 ‘g’ 和 ‘G’ 转换, 末尾的零不会从结果中被移除.</p>
<p>‘,’ 选项表示使用逗号作为千位分隔符. 对于感应区域设置的分隔符, 请改用 ‘n’ 整数表示类型.</p>
<p>‘_’ 选项表示对浮点表示类型和整数表示类型 ‘d’ 使用下划线作为千位分隔符. 对于整数表示类型 ‘b’, ‘o’, ‘x’ 和 ‘X’, 将为每 4 个数位插入一个下划线. 对于其他表示类型指定此选项则将导致错误.</p>
<p>width 是一个定义最小字段宽度的十进制整数. 如果未指定, 则字段宽度将由内容确定.</p>
<p>当未显式给出对齐方式时, 在 width 字段前加一个零 (‘0’) 字段将为数字类型启用感知正负号的零填充. 这相当于设置 fill 字符为 ‘0’ 且 alignment 类型为 ‘&#x3D;’.</p>
<p>precision 是一个十进制数字, 表示对于以 ‘f’ and ‘F’ 格式化的浮点数值要在小数点后显示多少个数位, 或者对于以 ‘g’ 或 ‘G’ 格式化的浮点数值要在小数点前后共显示多少个数位. 对于非数字类型, 该字段表示最大字段大小 —— 换句话说就是要使用多少个来自字段内容的字符. 对于整数值则不允许使用 precision.</p>
<p>最后, type 确定了数据应如何呈现.</p>
<p>可用的字符串表示类型是:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>‘s’</td>
<td>字符串格式.这是字符串的默认类型, 可以省略.</td>
</tr>
<tr>
<td>None</td>
<td>和 ‘s’ 一样.</td>
</tr>
</tbody></table>
<p>可用的整数表示类型是:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>‘b’</td>
<td>二进制格式. 输出以 2 为基数的数字.</td>
</tr>
<tr>
<td>‘c’</td>
<td>字符.在打印之前将整数转换为相应的unicode字符.</td>
</tr>
<tr>
<td>‘d’</td>
<td>十进制整数. 输出以 10 为基数的数字.</td>
</tr>
<tr>
<td>‘o’</td>
<td>八进制格式. 输出以 8 为基数的数字.</td>
</tr>
<tr>
<td>‘x’</td>
<td>十六进制格式. 输出以 16 为基数的数字, 使用小写字母表示 9 以上的数码.</td>
</tr>
<tr>
<td>‘X’</td>
<td>十六进制格式. 输出以 16 为基数的数字, 使用大写字母表示 9 以上的数码.</td>
</tr>
<tr>
<td>‘n’</td>
<td>数字. 这与 ‘d’ 相似, 不同之处在于它会使用当前区域设置来插入适当的数字分隔字符.</td>
</tr>
<tr>
<td>None</td>
<td>和 ‘d’ 相同.</td>
</tr>
</tbody></table>
<p>在上述的表示类型之外, 整数还可以通过下列的浮点表示类型来格式化 (除了 ‘n’ 和 None). 当这样做时, 会在格式化之前使用 float() 将整数转换为浮点数.</p>
<p>浮点数和小数值可用的表示类型有:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>‘e’</td>
<td>指数表示. 以使用字母 ‘e’ 来标示指数的科学计数法打印数字. 默认的精度为 6.</td>
</tr>
<tr>
<td>‘E’</td>
<td>指数表示. 与 ‘e’ 相似, 不同之处在于它使用大写字母 ‘E’ 作为分隔字符.</td>
</tr>
<tr>
<td>‘f’</td>
<td>定点表示. 将数字显示为一个定点数. 默认的精确度为 6.</td>
</tr>
<tr>
<td>‘F’</td>
<td>定点表示. 与 ‘f’ 相似, 但会将 nan 转为 NAN 并将 inf 转为 INF.</td>
</tr>
<tr>
<td>‘g’</td>
<td>常规格式. 对于给定的精度 p &gt;&#x3D; 1, 这会将数值舍入到 p 位有效数字;<br />再将结果以定点格式或科学计数法进行格式化, 具体取决于其值的大小.<br /><br />准确的规则如下: 假设使用表示类型 ‘e’ 和精度 p-1 进行格式化的结果具有指数值 exp. <br />则如果 -4 &lt;&#x3D; exp &lt; p, 该数字将使用表示类型 ‘f’ 和精度 p-1-exp 进行格式化.<br />否则的话, 该数字将使用表示类型 ‘e’ 和精度 p-1 进行格式化.<br />在两种情况下, 都会从有效数字中移除无意义的末尾零, 如果小数点之后没有数字则小数点也会被移除.<br />正负无穷, 正负零和 nan 会分别被格式化为 inf, -inf, 0, -0  和 nan, 无论精度如何设定.<br />精度 0 会被视为等同于精度 1. 默认精度为 6.</td>
</tr>
<tr>
<td>‘G’</td>
<td>常规格式. 类似于 ‘g’, 不同之处在于当数值非常大时会切换为 ‘E’. 无穷与 NaN 也会表示为大写形式.</td>
</tr>
<tr>
<td>‘n’</td>
<td>数字. 这与 ‘g’ 相似, 不同之处在于它会使用当前区域设置来插入适当的数字分隔字符.</td>
</tr>
<tr>
<td>‘%’</td>
<td>百分比. 将数字乘以 100 并显示为定点 (‘f’) 格式, 后面带一个百分号.</td>
</tr>
<tr>
<td>None</td>
<td>类似于 ‘g’, 不同之处在于当使用定点表示法时, 小数点后将至少显示一位.<br />默认精度与表示给定值所需的精度一样. 整体效果为与其他格式修饰符所调整的 str() 输出保持一致.</td>
</tr>
</tbody></table>
<p>*<em>未完待续…</em></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><em>1. <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/">Python 3.7.4 文档</a></em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zzZ5.xyz">zzZ5</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zzz5.xyz/2019/05/09/python/rules/python-rule-tips/">https://zzz5.xyz/2019/05/09/python/rules/python-rule-tips/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zzZ5.xyz" target="_blank">zzZ5的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/06/03/kT3orwCEb92zaue.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/11/python/rules/python-rules-style/" title="Python风格规范"><img class="cover" src="https://i.loli.net/2020/06/03/LYjJe4KXNT3nBMG.png" onerror="onerror=null;src='/assets/blogImg/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python风格规范</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/05/diary/diary-2019-0505/" title="毕业论文"><img class="cover" src="https://i.loli.net/2020/06/03/ZfY6BvhJu23V7Up.png" onerror="onerror=null;src='/assets/blogImg/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">毕业论文</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/04/20/python/numpy/python-numpy-01/" title="Python之Numpy库学习(1)"><img class="cover" src="https://i.loli.net/2020/07/07/iqrW95cCSPeyK8d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-20</div><div class="title">Python之Numpy库学习(1)</div></div></a></div><div><a href="/2019/04/21/python/numpy/python-numpy-02/" title="Python之Numpy库学习(2)"><img class="cover" src="https://i.loli.net/2020/07/07/iqrW95cCSPeyK8d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-21</div><div class="title">Python之Numpy库学习(2)</div></div></a></div><div><a href="/2019/04/22/python/numpy/python-numpy-03/" title="Python之Numpy库学习(3)"><img class="cover" src="https://i.loli.net/2020/07/07/iqrW95cCSPeyK8d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-22</div><div class="title">Python之Numpy库学习(3)</div></div></a></div><div><a href="/2019/04/23/python/numpy/python-numpy-04/" title="Python之Numpy库学习(4)"><img class="cover" src="https://i.loli.net/2020/07/07/iqrW95cCSPeyK8d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-23</div><div class="title">Python之Numpy库学习(4)</div></div></a></div><div><a href="/2020/05/28/python/others/python-designPatterns-01/" title="Python设计模式(1)"><img class="cover" src="https://i.loli.net/2020/07/07/AUqYyR67nH4msoN.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="title">Python设计模式(1)</div></div></a></div><div><a href="/2020/05/28/python/others/python-pipy/" title="发布Python包到PyPi"><img class="cover" src="https://i.loli.net/2020/06/03/P3RlUXFtqZYkeMG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="title">发布Python包到PyPi</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2020/06/03/OFvA9uNmodI8tki.png" onerror="this.onerror=null;this.src='/assets/blogImg/404.jpg'" alt="avatar"/></div><div class="author-info__name">zzZ5</div><div class="author-info__description">忙得要命</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zzZ5"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zzZ5" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/11657777" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="mailto:baoju_liu@foxmail.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Time will tell</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AB%8B%E5%8D%B3%E8%B7%B3%E5%87%BA%E4%B8%A4%E5%B1%82%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.</span> <span class="toc-text">如何立即跳出两层嵌套循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%87%BD%E6%95%B0%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Python函数是传值还是传引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">默认参数问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">Python中下划线的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E5%B9%B6%E4%BF%9D%E6%8C%81%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">删除序列相同元素并保持顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%B8%AD-%E5%8F%B7%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">Python中 * 号的特殊用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">用作参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BD%9C%E8%A7%A3%E5%8C%85"><span class="toc-number">6.2.</span> <span class="toc-text">用作解包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%A0%E5%B0%84%E5%88%B0%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">将运算符映射到函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%AD%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">格式字符串语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#field-name"><span class="toc-number">8.1.</span> <span class="toc-text">field_name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#conversion"><span class="toc-number">8.2.</span> <span class="toc-text">conversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#format-spec"><span class="toc-number">8.3.</span> <span class="toc-text">format_spec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">9.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/13/others/docker/" title="Docker使用说明"><img src="https://s2.loli.net/2023/09/13/nS6LMRyXTewZdAJ.png" onerror="this.onerror=null;this.src='/assets/blogImg/404.jpg'" alt="Docker使用说明"/></a><div class="content"><a class="title" href="/2023/09/13/others/docker/" title="Docker使用说明">Docker使用说明</a><time datetime="2023-09-13T01:49:00.000Z" title="发表于 2023-09-13 09:49:00">2023-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/diary/diary-2023-0901/" title="开始更新"><img src="https://i.loli.net/2020/06/03/uhAQD4IUr2kfoM6.gif" onerror="this.onerror=null;this.src='/assets/blogImg/404.jpg'" alt="开始更新"/></a><div class="content"><a class="title" href="/2023/09/01/diary/diary-2023-0901/" title="开始更新">开始更新</a><time datetime="2023-09-01T07:32:00.000Z" title="发表于 2023-09-01 15:32:00">2023-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/16/lot/mosquitto/" title="Ubuntu上使用Mosqitto部署Mqtt服务器"><img src="https://i.loli.net/2021/03/17/17lSbmuzf4wLnJh.png" onerror="this.onerror=null;this.src='/assets/blogImg/404.jpg'" alt="Ubuntu上使用Mosqitto部署Mqtt服务器"/></a><div class="content"><a class="title" href="/2021/03/16/lot/mosquitto/" title="Ubuntu上使用Mosqitto部署Mqtt服务器">Ubuntu上使用Mosqitto部署Mqtt服务器</a><time datetime="2021-03-16T13:11:00.000Z" title="发表于 2021-03-16 21:11:00">2021-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/04/web/django/django-nginx/" title="Ubuntu平台使用nginx部署Django项目"><img src="https://i.loli.net/2020/06/03/KmiQ2kSAJn4X3vZ.png" onerror="this.onerror=null;this.src='/assets/blogImg/404.jpg'" alt="Ubuntu平台使用nginx部署Django项目"/></a><div class="content"><a class="title" href="/2020/11/04/web/django/django-nginx/" title="Ubuntu平台使用nginx部署Django项目">Ubuntu平台使用nginx部署Django项目</a><time datetime="2020-11-04T08:06:00.000Z" title="发表于 2020-11-04 16:06:00">2020-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/13/python/matplotlib/python-matplotlib-nested%20pie%20chart/" title="使用Matplotlib绘制嵌套饼图"><img src="https://i.loli.net/2020/07/07/OxwJ84QzgPTfcpI.png" onerror="this.onerror=null;this.src='/assets/blogImg/404.jpg'" alt="使用Matplotlib绘制嵌套饼图"/></a><div class="content"><a class="title" href="/2020/10/13/python/matplotlib/python-matplotlib-nested%20pie%20chart/" title="使用Matplotlib绘制嵌套饼图">使用Matplotlib绘制嵌套饼图</a><time datetime="2020-10-13T01:30:00.000Z" title="发表于 2020-10-13 09:30:00">2020-10-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/06/03/kT3orwCEb92zaue.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zzZ5</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'wugk9aIpc580sE0GdxsCb7LL-MdYXbMMI',
      appKey: 'WmxJKdt4J543WQWOM9X0Usyt',
      avatar: 'monsterid',
      serverURLs: 'https://wugk9aip.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>